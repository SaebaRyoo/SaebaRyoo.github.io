---
title: React如何利用浏览器的事件循环来实现并发特性
categories:
- 前端
tags:
- React
---


本文只是用于将学习到的知识做一个梳理与总结

## 浏览器架构

现代浏览器通常采用多进程架构。每个进程都有独立的内存空间，相互隔离，提高浏览器的稳定性、安全性和性能。

以Chrome为例，浏览器的进程包含以下几个主要进程：

- 浏览器主进程: 负责协调整个浏览器的运行，包括用户界面、网络请求、子进程的创建和销毁等。
- 渲染进程: 将HTML/CSS/JS转化为用户可以交互的网页
- 网络进程: 处理网络请求、响应、DNS等
- GPU进程:负责处理图形渲染相关的任务，如2D、3D绘图等
- 插件进程:运行浏览器插件


## 渲染进程

对于我们的页面来说，最重要的就是`渲染进程`，它包含了以下的多个`线程`:

1.  主线程：负责处理用户输入、JavaScript 执行和页面布局计算等任务，是渲染进程中最重要的线程之一。
2.  渲染线程：负责将 HTML、CSS 和 JavaScript 转换为可视化的页面，其中包括页面布局、样式计算、绘制和合成等任务。
3.  合成线程：负责将页面中的多个图层合成为最终的显示内容，并将其发送到 GPU 进行渲染。
4.  JavaScript引擎线程：JavaScript 引擎线程负责解析和执行页面中的 JavaScript 代码
5.  事件线程：负责处理用户输入事件，如鼠标点击、键盘输入等，以及页面中的事件触发和处理
6.  IO线程: 负责接收其他进程传进来的消息
7.  ...

**在这当中，主线程最为繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件**。而浏览器则通过在`主线程`中实现`消息队列`和`事件循环系统`来调度这么多不同类型的任务。


我们可以通过下面的图片来了解`主线程`、`事件循环`、`消息队列`和其他线程之间的关系

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8d006695f24b78a0d2b5e567141761~tplv-k3u1fbpfcp-watermark.image?)

但是，`消息队列`是**先进先出**的。`主线程`所有执行任务都来自于`消息队列`。会面临以下两个问题

### 1. 如何处理**高优先级的任务**

比如，如何监控DOM节点的变化情况（节点的插入、修改、删除等动态变化），然后根据变化来处理相应的业务逻辑。一个通用设计就是利用js设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。

不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致**执行效率的下降**。如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。

这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的**执行效率**；如果采用异步方式，又会影响到**监控的实时性**。

那么该如何权衡**效率**和**实时性**呢?

针对这种情况，微任务就应运而生了，下面我们来看看微任务是如何权衡效率和实时性的。**通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

### 2. 如何解决单个任务执行时长过久的问题。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ced99956039b4f54958888a1516af929~tplv-k3u1fbpfcp-zoom-1.image)

从图中可以看到，所有任务都是在单线程中执行的，而由于每一帧的时间有限，如果某一个js任务非常的耗时，那么下面的任务(DOM解析、JS事件、布局计算、用户输入事件等)就需要等待很长时间。这也就是我们页面中**卡顿**的由来。

在页面中JavaScript 可以通过异步回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。比如`setTimeout`、`Promise`等

## 宏任务，微任务
虽然可以通过异步回调来解决单个任务执行时间过长的问题。

但是，`setTimeout`属于宏任务，`Promise`属于微任务

**宏任务**
- `setTimeout`的回调函数属于`宏任务`
- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

**微任务**
- `Promise`的回调属于`微任务`
- `MutationObserver` 的回调函数：当被观察的 DOM 节点发生变化时，`MutationObserver` 的回调函数会被添加到微任务队列中。
- `queueMicrotask` 方法：该方法可以将回调函数添加到微任务队列中，等待执行。该方法是 ES2020 标准中新增的。


`宏任务`与`微任务`的最主要区别在于它们的**执行时机**

`宏任务`是添加一个新的任务到`消息队列`中，如果使用`setTimeout`来异步执行一个操作时，时间间隔无法精准掌控，对于一些高实时性的需求不太符合。比如你在程序中使用`setTimeout`延迟`1000ms`去执行某个任务时，可能在这`1000ms`中已经触发了很多系统级的任务，它们已经被插入到了`消息队列`中。等到过了`1000ms`后`setTimeout`才将会它的回调插入到`消息队列`中，这就需要等待队列前的任务全部执行完了才能到它的回调


`微任务`是 在当前`宏任务`结束前再执行`微任务`，每个`宏任务`都关联了一个`微任务队列`。所以，只要在当前`宏任务`中触发了`微任务`，所有微任务的回调都会被添加到`微任务队列`中等待执行。这样，你再怎么交互，生成的`宏任务`都会排在当前的`宏任务`之后。



## React如何利用浏览器的特性来做“并发”

在了解了前面关于浏览器的特性。我们再回到react中看React为了**并发特性**做了哪些改动。

### time slice 与 fiber
在react16之前，一直是递归更新。而16之后，react提出了一个新的概念 **time slice**，便于将任务切分，然后在浏览器的空闲时间来执行任务，超出了空闲时间则将剩余任务往后推。但由于**递归更新中断后无法再继续**，所以react重构了它的代码，将递归更新改成了fiber这种链表结构。这样即使是暂停了，还能从暂停出的链表继续执行。

### 异步更新
我们可以在react的[react-reconciler包](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberSyncTaskQueue.js#L23)中找到`scheduleSyncCallback`方法，所有的`更新操作`都保存到了`syncQueue`队列中，然后通过`scheduleMicrotask`这个方法创建微任务，`flushSyncCallbacks`就是这个微任务的异步回调，而`flushSyncCallbacks`当中执行的就是所有的`更新操作`。这就解决了`组件更新时效性的问题`。


### Scheduler 调度器

现在，有了可中断的任务，并且`同步任务`被放到了`微任务`中执行。而且因为一般主流浏览器刷新频率为60Hz，即每16.6ms（1000ms / 60Hz）浏览器刷新一次。

所以react需要解决的就是如何利用每一帧中预留给js线程的时间来更新组件(在[scheduler源码](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L119)中，react预留了5ms)。当超过预留时间后，react就会中断更新，等待下一帧的空闲时间继续从`被中断的fiber`处执行。这样就尽可能的避免了任务执行时间过长而出现`掉帧`、`卡顿`的现象


## 总结

react 利用浏览器的渲染进程主线程的`事件循环`以及`宏任务`、`微任务`的特点，将原有的数据结构改变为`Fiber`这种可中断的链表结构。
并且通过将所有的`更新操作`使用`微任务`来执行，解决组件`更新时效性`问题。然后再实现了`调度器`来完成任务的中断和继续。


## 参考
- [浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601?tab=catalog)
- [react技术揭秘](https://react.iamkasong.com/#%E5%AF%BC%E5%AD%A6%E8%A7%86%E9%A2%91)
- [从零实现React 18](https://appjiz2zqrn2142.pc.xiaoe-tech.com/p/t_pc/goods_pc_detail/goods_detail/p_638035c1e4b07b05581d25db)
