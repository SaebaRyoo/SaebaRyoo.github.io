---
title: 浏览器相关知识
categories:
- 前端
tags: 
- 浏览器
---
## 浏览器的工作原理
https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/

## CSS
1. css外部资源的由独立的线程异步加载
2. css会阻塞DOM渲染，不会阻塞解析。因为渲染依赖css样式，如果不阻塞，网页的样式会在渲染过程中变化，且可能会造成重绘和回流。

## Script元素
### 工作原理
1. 如果DOM 树解析到外联**<script>**时会阻塞住，在它加载并且执行完之前，不会往下解析 DOM 树。
```
// test2.js
const num = 100000 * 50000;
for (let i = 0; i < num ;i++) {
}
```

```
<script src="./test2.js"></script>
<body>
    <div>我会在外部js脚本加载完成后执行</div>
</body>
```
2. 给外部脚本添加上**defer**，则会延迟脚本执行。
```
<script src="./test2.js" defer></script>
<body>
    <div>我会在外部js脚本加载前执行</div>
</body>
    
```
3. js引擎执行完毕。控制权交还给渲染引擎，恢复解析DOM。
4. 内联script中的js代码阻塞页面的渲染。
```
<body>
    <div>我会在内联script执行完后再渲染</div>
    <script>
        const num = 100000 * 50000;
        for (let i = 0; i < num ;i++) {
        }
    </script>
</body>

```

### 如何减少重排和重绘
> 首先要了解的是什么是重排或者叫回流，什么是重绘；
1. 重排： 重排必定伴随着重绘
    1) 当页面首次渲染时 
    2) 当元素的尺寸、位置发生变化时，
    3) 当 字体大小发生变化时 
    4) 浏览器窗口发生变化 
    5) 设置style样式 
    6) 新增和删除可见元素 
    7) 激活CSS伪类（例如：:hover）
    8) 查询某些属性或者方法时会触发重排
常见的属性如下：
offsetTop、offsetLeft、 offsetWidth、offsetHeight、
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight
常见的方法：
getComputedStyle、currentStyle。主要是为了确保准确性。
2. 重绘：重绘不一定会造成重排
color
border-style
visibility
background
text-decoration
background-image
background-position
background-repeat
outline-color
outline
outline-style
border-radius
outline-width
box-shadow
background-size

#### 解决方法
1. 读写分离
以下的代码会造成4次重排和4次重绘，因为在console中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。

**因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘**
```
div.style.left = '10px';
console.log(div.offsetLeft);
div.style.top = '10px';
console.log(div.offsetTop);
div.style.width = '20px';
console.log(div.offsetWidth);
div.style.height = '20px';
console.log(div.offsetHeight);
```

将代码改成如下，则只会造成一次重排。因为在第一个console的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。
```
div.style.left = '10px';
div.style.top = '10px';
div.style.width = '20px';
div.style.height = '20px';
console.log(div.offsetLeft);
console.log(div.offsetTop);
console.log(div.offsetWidth);
console.log(div.offsetHeight);

```

2. 样式集中改变
```
div.style.left = '10px';
div.style.top = '10px';
div.style.width = '20px';
div.style.height = '20px';
```

虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下：
建议通过改变class或者csstext属性集中改变样式
```
// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top  = top  + "px";
// good 
el.className += " theclassname";
// good
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
```

3. 缓存布局信息
```
// bad 强制刷新 触发两次重排
div.style.left = div.offsetLeft + 1 + 'px';
div.style.top = div.offsetTop + 1 + 'px';

// good 缓存布局信息 相当于读写分离
var curLeft = div.offsetLeft;
var curTop = div.offsetTop;
div.style.left = curLeft + 1 + 'px';
div.style.top = curTop + 1 + 'px';
```

4. 离线改变dom


    - 隐藏要操作的dom
           在要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为 
           不可见的元素不会触发重排和重绘。
               ```
                     dom.display = 'none'
                    // 修改dom样式
                    dom.display = 'block'
               ```
    - 通过使用DocumentFragment创建一个dom碎片,在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。
    - 复制节点，在副本上工作，然后替换它！


5. position属性为absolute或fixed
position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响
6. 优化动画


可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小
动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：
比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。


启用GPPU加速
此部分来自优化CSS重排重绘与浏览器性能
GPU(图像加速器)：
GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。
GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。
```
/*
 * 根据上面的结论
 * 将 2d transform 换成 3d
 * 就可以强制开启 GPU 加速
 * 提高动画性能
 */
div {
  transform: translate3d(10px, 10px, 0);
}
```


### 垃圾回收机制
V8中，将堆内存分为**新生代（副垃圾回收器）**，**老生代（主垃圾回收器）**。**新生代**组要存储一些存活时间短的对象，**老生代**存储存活时间长的对象。

#### 工作机制
1. 标记空间中活动对象和非活动对象。活动对象就是还在使用的对象，非活动对象就是可以进行回收的对象
2. 回收非活动对象占据的内存。即在标记完成之后，统一清理非活动对象的内存
3. 做内存整理，一般在频繁的垃圾回收后，会出现大量不连贯的内存空间，叫做**内存碎片**。当内存中出现大量的内存碎片后，就可能出现内存不足的情况。所以需要整理。但这一步是可选的，因为有的垃圾回收器不会产生**内存碎片**，如**副垃圾回收器**

#### 副垃圾回收器
**新生代**采用**Scavenge算法** ，即将**新生代**一分为二，分别为对象区域，空闲区域。如下图：
![scavenge](https://user-images.githubusercontent.com/18700225/72214201-4b8a0a80-3538-11ea-9916-e134c94a3896.png)

当对象区域快要占满时，就会执行一次垃圾回收操作。在垃圾回收的过程中标记非活动对象，标记完成后就进入垃圾清理阶段，副垃圾回收器会将存活的对象复制到空闲区域，并进行有序的排列。这个过程中就已经进行了内存整理。

然后对象区域和空闲区域的角色对换。

因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中


#### 主垃圾回收器
V8中的主垃圾回收器采用**Mark-Sweep（标记-清除）**，该算法会产生大量不连续的内存碎片。
所以又有了**标记 - 整理（Mark-Compact）** 它会先将所有存活的对象排列在一起，然后清理端另一边的非存活对象

#### 全停顿（Stop - The - World）
由于js是运行在主线程上的，一旦执行垃圾回收算法，会阻塞所有js脚本执行。在清理过程中，主线程无法执行任何操作，会明显的影响到用户体验。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法
![increase](https://user-images.githubusercontent.com/18700225/72214337-c2c09e00-353a-11ea-8bde-9ffb891a53ef.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。